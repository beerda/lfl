% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lcut.R
\name{lcut}
\alias{lcut}
\alias{lcut.default}
\alias{lcut.factor}
\alias{lcut.logical}
\alias{lcut.numeric}
\alias{lcut.data.frame}
\alias{lcut.matrix}
\title{Transform data into a \code{fsets} S3 class of linguistic fuzzy attributes}
\usage{
lcut(x, ...)

\method{lcut}{default}(x, ...)

\method{lcut}{factor}(x, name = deparse(substitute(x)), ...)

\method{lcut}{logical}(x, name = deparse(substitute(x)), ...)

\method{lcut}{numeric}(
  x,
  context = minmax,
  atomic = c("sm", "me", "bi", "lm", "um", "ze", "neg.sm", "neg.me", "neg.bi", "neg.lm",
    "neg.um"),
  hedges = c("ex", "si", "ve", "ty", "-", "ml", "ro", "qr", "vr"),
  name = NULL,
  hedgeParams = defaultHedgeParams,
  ...
)

\method{lcut}{data.frame}(
  x,
  context = minmax,
  atomic = c("sm", "me", "bi", "lm", "um", "ze", "neg.sm", "neg.me", "neg.bi", "neg.lm",
    "neg.um"),
  hedges = c("ex", "si", "ve", "ty", "-", "ml", "ro", "qr", "vr"),
  ...
)

\method{lcut}{matrix}(x, ...)
}
\arguments{
\item{x}{Data to be transformed: if it is a numeric vector, matrix, or data
frame, then the creation of linguistic fuzzy attributes takes place. For
other data types the \code{\link[=fcut]{fcut()}} function is called implicitly.}

\item{...}{Other parameters to some methods.}

\item{name}{A name to be added as a suffix to the created fuzzy attribute
names. This parameter can be used only if \code{x} is a numeric vector. If
\code{x} is a matrix or data frame, \code{name} should be NULL because the
fuzzy attribute names are taken from column names of parameter \code{x}.
The \code{name} is also used as a value for the \code{vars} attribute of the resulting
\code{\link[=fsets]{fsets()}} instance.}

\item{context}{A definition of context of a numeric attribute. It must be
an instance of an S3 class \code{\link[=ctx3]{ctx3()}}, \code{\link[=ctx5]{ctx5()}}, \code{\link[=ctx3bilat]{ctx3bilat()}} or \code{\link[=ctx5bilat]{ctx5bilat()}}.

If \code{x} is a matrix or data frame then \code{context} should be a named
list of contexts for each \code{x}'s column.}

\item{atomic}{A vector of atomic linguistic expressions to be used for
creation of fuzzy attributes.}

\item{hedges}{A vector of linguistic hedges to be used for creation of fuzzy
attributes.}

\item{hedgeParams}{Parameters that determine the shape of the hedges}
}
\value{
An object of S3 class \code{fsets} is returned, which is a numeric matrix
with columns representing the fuzzy attributes. Each source columm of the
\code{x} argument corresponds to multiple columns in the resulting matrix.
Columns will have names derived from used \eqn{hedges}, atomic expression,
and \eqn{name} specified as the optional parameter.

The resulting object would also have set the \code{\link[=vars]{vars()}} and \code{\link[=specs]{specs()}}
properties with the former being created from original
column names (if \code{x} is a matrix or data frame) or the \code{name}
argument (if \code{x} is a numeric vector). The \code{\link[=specs]{specs()}}
incidency matrix would be created to reflect the following order of the
hedges: \eqn{"ex" < "si" < "ve" < "-" < "ml" < "ro" < "qr" < "vr"} and
\eqn{"ty" < "" < "ml" < "ro" < "qr" < "vr"}.  Fuzzy attributes created from
the same source numeric vector (or column) would be ordered that way, with other fuzzy attributes
(from the other source) being incomparable.
}
\description{
This function creates a set of linguistic fuzzy attributes from crisp data.
Numeric vectors, matrix or data frame columns are transformed into a set of
fuzzy attributes, i.e. columns with membership degrees. Factors and other
data types are transformed to fuzzy attributes by calling the
\code{\link[=fcut]{fcut()}} function.
}
\details{
The aim of this function is to transform numeric data into a set of fuzzy
attributes.  The resulting fuzzy attributes have direct linguistic
interpretation. This is a unique variant of fuzzification that is suitable
for the inference mechanism based on Perception-based Linguistic Description
(PbLD) -- see \code{\link[=pbld]{pbld()}}.

A numeric vector is transformed into a set of fuzzy attributes accordingly
to the following scheme:

\eqn{<hedge> <atomic expression>}

where \eqn{<atomic expression>} is an atomic linguistic expression, a value
from the following possibilities (note that the allowance of atomic expressions
is influenced with \code{context} being used - see \link{ctx} for details):
\itemize{
\item \code{neg.bi}: big negative (far from zero)
\item \code{neg.um}: upper medium negative (between medium negative and big negative)
\item \code{neg.me}: medium negative
\item \code{neg.lm}: lower medium negative (between medium negative and small negative)
\item \code{neg.sm}: small negative (close to zero)
\item \code{ze}: zero
\item \code{sm}: small
\item \code{lm}: lower medium
\item \code{me}: medium
\item \code{um}: upper medium
\item \code{bi}: big
A \eqn{<hedge>} is a modifier that further concretizes the atomic expression
(note that not each combination of hedge and atomic expression is allowed -
see \link{allowed.lingexpr} for more details):
\item \code{ex}: extremely,
\item \code{si}: significantly,
\item \code{ve}: very,
\item \code{ty}: typically,
\item \code{-}: empty hedge (no hedging),
\item \code{ml}: more or less,
\item \code{ro}: roughly,
\item \code{qr}: quite roughly,
\item \code{vr}: very roughly.
}

Accordingly to the theory developed by Novak (2008), not every hedge is
suitable with each atomic #' expression (see the description of the \code{hedges}
argument).  The hedges to be used can be selected with the \code{hedges} argument.
Function takes care of not to use hedge together with an un-applicable atomic
expression by itself.

Obviously, distinct data have different meaning of what is "small",
"medium", or "big" etc.  Therefore, a \code{context} has to be set that
specifies sensible values for these linguistic expressions.

If a matrix (resp. data frame) is provided to this function instead of
a single vector, all columns are processed the same way.

The function also sets up properly the \code{\link[=vars]{vars()}} and
\code{\link[=specs]{specs()}} properties of the result.
}
\examples{

# transform a single vector
x <- runif(10)
lcut(x, name='age')

# transform single vector with a custom context
lcut(x, context=ctx5(0, 0.2, 0.5, 0.7, 1), name='age')

# transform all columns of a data frame
# and do not use any hedges
data <- CO2[, c('conc', 'uptake')]
lcut(data)


# definition of custom contexts for different columns
# of a data frame while selecting only "ve" and "ro" hedges.
lcut(data,
     context=list(conc=minmax,
                  uptake=ctx3(0, 25, 50)),
     hedges=c('ve', 'ro'))


# lcut on non-numeric data is the same as fcut()
ff <- factor(substring("statistics", 1:10, 1:10), levels = letters)
lcut(ff)

}
\references{
V. Novak, A comprehensive theory of trichotomous evaluative
linguistic expressions, Fuzzy Sets and Systems 159 (22) (2008) 2939--2969.
}
\seealso{
\code{\link[=fcut]{fcut()}}, \code{\link[=fsets]{fsets()}}, \code{\link[=vars]{vars()}}, \code{\link[=specs]{specs()}}
}
\author{
Michal Burda
}
\keyword{models}
\keyword{multivariate}
\keyword{robust}
